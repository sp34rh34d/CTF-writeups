## Name: ezcoppersmith
#### Category: crypto
#### Difficulty: N/A
#### Description: Easy coppersmith?

## Procedure
In this crypto chall, we can see the following:
1) The code have used a os.urandom(70) to generate 70 bytes of random data at the start and end.
2) We concatenate these bytes with the string b"CSCTF{fake_flag}", forming the complete flag.
3) Converting the flag to an integer using bytes_to_long function.
4) The public exponent ```e``` is defined as 0x10001 (65537), which is a common value in RSA.
5) The prime number ```p``` is generated using getPrime(1024).
6) The second prime number ```q``` is was created using ```nextprime(p + getrandbits(512))```, where ```getrandbits(512)``` adds a random variation to ensure that ```q``` is different from ```p```.

```
import os
from Crypto.Util.number import bytes_to_long, getPrime
from random import getrandbits
from sympy import nextprime
flag = os.urandom(70)+b"CSCTF{fake_flag}"+os.urandom(70)
flag = bytes_to_long(flag)
e = 0x10001
p = getPrime(1024)
q = nextprime(p+getrandbits(512))
n = p*q
ct = pow(flag,e,n)

print(f"{n = }")
print(f"{ct = }")
```

The creating of  ```q```, can allow us to recover the ```private key``` value,  because it introduces a predictable relationship between 
```p``` and ```q```, Instead of being completely independently generated prime numbers, ```q``` which is very close to ```p```, which can be exploited with factorize N.

the following script allow us to recover the value for ```p``` and ```q```

```
from sympy.ntheory import factorint

N=18644771606497209714095542646224677588981048892455227811334258151262006531336794833359381822210403450387218291341636672728427659163488688386134401896278003165147721355406911673373424263190196921309228396204979060454870860816745503197616145647490864293442635906688253552867657780735555566444060335096583505652012496707636862307239874297179019995999007369981828074059533709513179171859521707075639202212109180625048226522596633441264313917276824985895380863669296036099693167611788521865367087640318827068580965890143181999375133385843774794990578010917043490614806222432751894223475655601237073207615381387441958773717
primes = factorint(N)
print(primes)
```

output

```
{136545858986998246186017611284664707398999797498692946608523559469499827972094856292942650773093192162138423617662757531574919967461255241533395505995030617210156281091030371701198122810180540132811734185012657022629634425970608413451030604056026161196348671111947083652764868355722990294951453693249819907769: 1, 136545858986998246186017611284664707398999797498692946608523559469499827972094856292942650773093192162138423617662757531574919967461255241533395505995030621481175031499344949735265383560242346915071826552296754272942746356998125287415246140255211942791159132750757895494949215741681277852308288626896929744893: 1}
```

from here, we can get the [Euler totient (phi)](https://leimao.github.io/article/RSA-Algorithm/) of ```N```, and recover the private key used to encrypt the flag
```
#modulus
N=18644771606497209714095542646224677588981048892455227811334258151262006531336794833359381822210403450387218291341636672728427659163488688386134401896278003165147721355406911673373424263190196921309228396204979060454870860816745503197616145647490864293442635906688253552867657780735555566444060335096583505652012496707636862307239874297179019995999007369981828074059533709513179171859521707075639202212109180625048226522596633441264313917276824985895380863669296036099693167611788521865367087640318827068580965890143181999375133385843774794990578010917043490614806222432751894223475655601237073207615381387441958773717

#exponent
e=65537
#primes value recovered with factorize
p=136545858986998246186017611284664707398999797498692946608523559469499827972094856292942650773093192162138423617662757531574919967461255241533395505995030617210156281091030371701198122810180540132811734185012657022629634425970608413451030604056026161196348671111947083652764868355722990294951453693249819907769
q=136545858986998246186017611284664707398999797498692946608523559469499827972094856292942650773093192162138423617662757531574919967461255241533395505995030621481175031499344949735265383560242346915071826552296754272942746356998125287415246140255211942791159132750757895494949215741681277852308288626896929744893

#cipher text
ct=814602066169451977605898206043894866509050772237095352345693280423339237890197181768582210420699418615050495985283410604981870683596059562903004295804358339676736292824636301426917335460641348021235478618173522948941541432284037580201234570619769478956374067742134884689871240482950578532380612988605675957629342412670503628580284821612200740753343166428553552463950037371300722459849775674636165297063660872395712545246380895584677099483139705934844856029861773030472761407204967590283582345034506802227442338228782131928742229041926847011673393223237610854842559028007551817527116991453411203276872464110797091619

#Euler totient
phi = (p-1)*(q-1)

#private key
d = pow(e,-1,phi)

#flag in big integer
pt=pow(ct,d,N)

print(bytes.fromhex(hex(pt).replace('0x','')))
```

output 

```
-k\xd8\\\xf1\x0f1\xca\xde\xbf\xab\xca\x8fo\xb5\x9fm\x13<\x0c/\x04c\x0e}\xb9\xf4q\x9196+X\x89\x80\xcc\x15\xbbW\x9a!n\xb6`\xa1\x10\xc6\xb2\xd3\xf0\x9c\x80O9\xd0\xaa\xa6\x0e\xcd\x91#\xe7T4\xd7\xa9\xd7JPlCSCTF{c0pp3rsm1th_1s_a_m4th_g0d_n0_d0ub7}\x92\xac\x0e\x83\xcdB:<\x08J2R\x8c\xb8\x06-\n\x97V3i\xd1\xa1\xb6\x06\x80\xff\x15;\x8aw\x17\xf5\xb3\xb8\x95w\xfd\xf0h\xb3jzk\x9aR\x1de\x91'\x83h\xe6!\x99\x19\xfb\x88]\x96\x93\x00\x9e\xd6\xac\xca\xcd\xb5(\t
```

flag ```CSCTF{c0pp3rsm1th_1s_a_m4th_g0d_n0_d0ub7}```
